{
  "hash": "722862a52dca1a190a30e71bb1e2cea7",
  "result": {
    "markdown": "---\ntitle: \"Getting Data From Many Excel Workbooks, with Python\"\nauthor: \"David De Sa\"\ndate: \"2023-03-12\"\ncategories: [python, excel, automation]\nformat:\n  html:\n    code-fold: true\n    toc: true\n    code-tools: true\n---\n\n## TL;DR\nThis article is about using Python to reach into many excel files that have a similar spreadsheet structure so as to pull out data from those sheets, potentially spread across multiple folders, into one place for aggregate use.\n\n# When your Excel is more like Excalibur ^[Don't worry I didnt spend too long thinking about this, it just came to me. And if you don't like it, we agree to disagree.]\nIt seems like an all too common tragedy that lots of team operate on the basis of sheets that were thrown together at some point in the distant past with varying degrees of thought put into future use cases. Now here you are, with the data you need like gold ore entombed in mountains of excel sheets. The irretrievable Excalibur in the stone.\n\nI encountered a problem where I had hundreds of excel sheets (each for a specific week) with data tables in each, and I needed to know which records in them met a certain criteria. I made some code in Python to pull the data out, this article will walk through it along with the video: \n\n## What Exactly Does This Code Do?\nThis code goes over all excel files with a name matching a specified pattern in a given folder (and its subfolders). In this example, these are invoices. The code will generate two master data tables in a new worksheet, one table with a row for each line item across all invoices, and another table with one row for each invoice with the bottom line information. \n\n## Is This For You?\nThis article is aimed at people who may have never used Python before but have some experience with coding of one form or another; I'll go through each line so you can understand and customize the code to your own use case. This is built on an assumption that the many sheets you want to dig into have at least some rhyme/reason as to their naming conventions, and internal sheet structure. Anything is possible with programming, but the more consistent your sheets, the simpler this code can be.\n\n# INSERT VIDEO LINK HERE, and GITHUB link beloW!\n\n### Try It Yourself!\nIf you want to run it yourself, you can find the code on my GitHub page. You'll need to [install Python and Jupyter](https://www.youtube.com/watch?v=qI3P7zMMsgY).^[Not my video, but I recommend it. It might seem daunting or like overkill, but trust me, it's the right way to go.] Python is the programming langauge we're using, Jupyter is the tool for organizing and executing blocks of Python commands so that we can understand, debug, and execute bits and peices of code at a time instead of always running the whole thing.\n\n# Code Walkthrough\n## Example Files\nI'm using an invoice template I picked up from [this website](https://www.myexcelonline.com/blog/free-excel-templates-and-spreadsheets/#section66).^[I'm not affiliated with it.]\n\nI have a master Invoice folder, with sub folders for each year. To simulate rela world messiness, some of these subfolders have different name patterns, and some have \"Paid\" vs \"Unpaid\" secondary folders wheres as some do not.\n\n![Main Folder](Folders1.png){#fig-f1}  \n\n![A Sub-Folder](Folders2.png){#fig-f2}\n\n![Another Sub-Folder](Folders3.png){#fig-f3}\n\n\n## Dependencies\nThe opensource tools from [Openpyxl](https://openpyxl.readthedocs.io/en/stable/) are what make this possible. Big thanks to everyone who has built them up. Other than that we're just using really standard Python libraries^[A library is a collection of code files defining functions and other kinds of code objects that we can use ourselves and build on. Like a toolbox.].\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nfrom openpyxl import load_workbook\nimport openpyxl as pyxl\nfrom pathlib import Path\nimport os\nfrom datetime import datetime\n```\n:::\n\n\n## Debugging\nThe most common thing I tripped over in making this was typos and what not in my file paths. You can use this function to test whether or not a path you've entered is valid. \n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nPath(r\"C:\\Invoices\").exists()\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\nTrue\n```\n:::\n:::\n\n\n## Specifying Which Files\nI made code blocks for 2 options; specifying all files manually, or specifying a directory and file name pattern to search for. Either way we start by initializing the container that our data will be stored in:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nsubitems = []  # Will contain the data we're aggregating for all items on invoices\ninvoiceTotal = []  # Will contain the final bottom-line data for each invoice\nfls = []  # Stores file paths for excel files to be searched\n```\n:::\n\n\n### Option 1: Naming Each File\nThe most controlled way would be to list all the files with the full path, something like this:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nprint(\"fls.append(r\\\"C:\\Invoices\\Invoices 2022\\Invoice 1.xlsx\\\")\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfls.append(r\"C:\\Invoices\\Invoices 2022\\Invoice 1.xlsx\")\n```\n:::\n:::\n\n\nBut I felt it was such an eyesore, and the folder structure made me prone to typo mistakes. So I made a helper function that would tighten things up, requiring only the file name and invoice year, and 'paid' vs 'unpaid' as input, and then spitting out the whole file path. The function uses the file year to decide which folder naming structure to use.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n# Helper function to build path strings when iterating through multiple files\n\n\ndef pthBld(flNm, flExtn=\"\", path_building_variable=('Paid', 0)):\n    \"\"\"Take a file name and expected file type, and based on some other input, add the rest of the file path for reference by workbook opening function\"\"\"\n    if flExtn != \"\":\n        flExtn = \".\"+flExtn\n    tp = path_building_variable[0]\n    yr = path_building_variable[1]\n    if yr == 22:\n        return (r\"C:\\Invoices\\Invoices 2022\"+chr(92)+tp+chr(92)+flNm+flExtn)\n    else:\n        return (r\"C:\\Invoices\\Invoices '\"+str(yr)+chr(92)+tp+chr(92)+flNm+flExtn)\n\n```\n:::\n\n\nAlways good to test a function is working after making it.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\np = pthBld('Invoice 3', \"xlsx\", ('unPaid', 22))\np, \"Exists?: \"+str(Path(p).exists())\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n('C:\\\\Invoices\\\\Invoices 2022\\\\unPaid\\\\Invoice 3.xlsx', 'Exists?: True')\n```\n:::\n:::\n\n\nThen, the process of specifying all the files to search by individual names is just running a bunch of commands like this:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nprint(\"fls.append(pthBld('Invoice 1',\\\"xlsx\\\",('Paid',22)))\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfls.append(pthBld('Invoice 1',\"xlsx\",('Paid',22)))\n```\n:::\n:::\n\n\n### Option 2: Full Directory Search on File names\nIf there are too many files names to sepcify one by one, or if there is some identifying pattern to the file names of interest, this option can be used. The code looked through the specified folder in entirety, including subfolders, and if a file name meets a criteria, saves the path to perform the data retrieval on that file.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\ndef list_dir(directory):\n    \"\"\"This function will print out the path for every file in the specified directory (and any further nested directories)\"\"\"\n    output = []  # initialize\n    for filename in os.listdir(directory):\n        f = os.path.join(directory, filename)\n        # checking if it is a file\n        if os.path.isfile(f):\n            output.append(f)\n        elif os.path.isdir(f):\n            output.extend(list_dir(f))\n    return output\n\n```\n:::\n\n\nWhat if you wanted to omit one or multiple folders entirely? The 'else if' branch in the above function could have an extra required condition added to it such that only folders with a certain name structure, for example, are searched.\n\nHere is what we get when we test that function:\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nlist_dir(r\"C:\\Invoices\")  # Test it works\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n['C:\\\\Invoices\\\\Aggregated_Data.xlsx',\n \"C:\\\\Invoices\\\\Invoices '21\\\\junk_Data.xlsx\",\n \"C:\\\\Invoices\\\\Invoices '21\\\\Paid\\\\invoice 1.xlsx\",\n \"C:\\\\Invoices\\\\Invoices '21\\\\Paid\\\\invoice 2.xlsx\",\n \"C:\\\\Invoices\\\\Invoices '21\\\\Unpaid\\\\invoice 3.xlsx\",\n \"C:\\\\Invoices\\\\Invoices '23\\\\invoice 1.xlsx\",\n \"C:\\\\Invoices\\\\Invoices '23\\\\invoice 2.xlsx\",\n \"C:\\\\Invoices\\\\Invoices '23\\\\invoice 3.xlsx\",\n \"C:\\\\Invoices\\\\Invoices '23\\\\junk_Data.xlsx\",\n 'C:\\\\Invoices\\\\Invoices 2022\\\\junk_Data.xlsx',\n 'C:\\\\Invoices\\\\Invoices 2022\\\\Paid\\\\invoice 1.xlsx',\n 'C:\\\\Invoices\\\\Invoices 2022\\\\Paid\\\\invoice 2.xlsx',\n 'C:\\\\Invoices\\\\Invoices 2022\\\\Paid\\\\junk_Data.xlsx',\n 'C:\\\\Invoices\\\\Invoices 2022\\\\Unpaid\\\\invoice 3.xlsx']\n```\n:::\n:::\n\n\nHaving a list of *all* files within the directory, we need to screen for just the ones we want. For the sake of this example I simply keep the file paths that have the text \"invoice\" in the last 15 characters of the path:\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nfor f in list_dir(r\"C:\\Invoices\"):\n    if \"invoice\" in f.lower()[-15:]:\n        fls.append(f)\n```\n:::\n\n\nAnd testing the output is as expected;\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nfls\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n[\"C:\\\\Invoices\\\\Invoices '21\\\\Paid\\\\invoice 1.xlsx\",\n \"C:\\\\Invoices\\\\Invoices '21\\\\Paid\\\\invoice 2.xlsx\",\n \"C:\\\\Invoices\\\\Invoices '21\\\\Unpaid\\\\invoice 3.xlsx\",\n \"C:\\\\Invoices\\\\Invoices '23\\\\invoice 1.xlsx\",\n \"C:\\\\Invoices\\\\Invoices '23\\\\invoice 2.xlsx\",\n \"C:\\\\Invoices\\\\Invoices '23\\\\invoice 3.xlsx\",\n 'C:\\\\Invoices\\\\Invoices 2022\\\\Paid\\\\invoice 1.xlsx',\n 'C:\\\\Invoices\\\\Invoices 2022\\\\Paid\\\\invoice 2.xlsx',\n 'C:\\\\Invoices\\\\Invoices 2022\\\\Unpaid\\\\invoice 3.xlsx']\n```\n:::\n:::\n\n\nWe got rid of the junk_data.xlsx files.\n\n## Retrieving The Data\nHaving specified all the files paths for our excel files, we need to reach into them and grab that data into memory using Python. To do that, we iterate over the list of filepaths, opening the workbook using openpyxl. In this example I'm grabbing all data in each item row of the invoice to one table, and the bottom-line information to a second table. For the first operation, I iterate through the cells in which I know the data could be, just recording something if data is found. I use a list comprehension to carry out the workbook.cell(row,col).value function in one line of code but across all columns of the table, casting the date value to a string so that python doesn't convert it to a more complex datetime format which is admittedly more handy for anything but transferring back into excel.\n\nIn the second portion of the retrieval function for a given file, I use a more verbose and explicit way of grabbing all the data. There isn't any question for these data as to whether or nto they will be there, since each invoice has one of these data points, where as number of line items was variable. \n\nWhile iterating over the various workbooks, the data from each is stored in 2 lists. Each list is sent to a list of lists which will be used for reporting.\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nfor fl in fls:\n    wb = load_workbook(filename=fl, data_only=True)\n    # First record data for the sub-items list\n    print(str(1+fls.index(fl))+chr(92)+str(len(fls)), fl)\n    for i in range(8, 30):  # Note arbitrary assumption on row limit. Starting point from existing sheet structure\n        # Grab invoice admin data\n        if wb['Commercial Invoice'].cell(row=i, column=3).value != None:\n            data = [fl]  # include filepath in data dump\n            # Invoice number to data dump\n            data.append(wb['Commercial Invoice'].cell(row=3, column=8).value)\n            data.extend([wb['Commercial Invoice'].cell(row=i, column=c).value if type(wb['Commercial Invoice'].cell(row=i, column=c).value) != datetime else str(\n                wb['Commercial Invoice'].cell(row=i, column=c).value) for c in range(2, 9)])  # Convert any data to string.. when re printed to excel it will cast to appropriate type\n            subitems.append(data)\n        else:\n            pass\n    # Now record to totals\n    data2 = [fl]  # initialize with filepath\n    data2.append(str(wb['Commercial Invoice'].cell(\n        row=4, column=8).value))  # invoice data\n    data2.append(wb['Commercial Invoice'].cell(\n        row=3, column=8).value)  # invoice num\n    data2.append(wb['Commercial Invoice'].cell(\n        row=13, column=8).value)  # subtotal\n    data2.append(wb['Commercial Invoice'].cell(row=14, column=8).value)  # VAT\n    data2.append(wb['Commercial Invoice'].cell(\n        row=15, column=8).value)  # Other Tax\n    data2.append(wb['Commercial Invoice'].cell(\n        row=16, column=8).value)  # Delivery\n    data2.append(wb['Commercial Invoice'].cell(\n        row=17, column=8).value)  # Deposit Recieved\n    data2.append(wb['Commercial Invoice'].cell(\n        row=18, column=8).value)  # Total\n    invoiceTotal.append(data2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\\9 C:\\Invoices\\Invoices '21\\Paid\\invoice 1.xlsx\n2\\9 C:\\Invoices\\Invoices '21\\Paid\\invoice 2.xlsx\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n3\\9 C:\\Invoices\\Invoices '21\\Unpaid\\invoice 3.xlsx\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n4\\9 C:\\Invoices\\Invoices '23\\invoice 1.xlsx\n5\\9 C:\\Invoices\\Invoices '23\\invoice 2.xlsx\n6\\9 C:\\Invoices\\Invoices '23\\invoice 3.xlsx\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\ProgramData\\Anaconda\\lib\\site-packages\\openpyxl\\worksheet\\header_footer.py:48: UserWarning:\n\nCannot parse header or footer so it will be ignored\n\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n7\\9 C:\\Invoices\\Invoices 2022\\Paid\\invoice 1.xlsx\n8\\9 C:\\Invoices\\Invoices 2022\\Paid\\invoice 2.xlsx\n9\\9 C:\\Invoices\\Invoices 2022\\Unpaid\\invoice 3.xlsx\n```\n:::\n:::\n\n\nAs always, good to test that it worked. here we can see how many dsub items in total we observed across all invoices and see a sample of the first one. Likewise for the number of quotes overall, and a sample of the bottom line info collected.\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\n# Check we got what we wanted\nlen(subitems), subitems[0], len(invoiceTotal), invoiceTotal[0]\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n(9,\n [\"C:\\\\Invoices\\\\Invoices '21\\\\Paid\\\\invoice 1.xlsx\",\n  34567,\n  '2023-03-12 00:00:00',\n  789807,\n  'Wooden Blocks',\n  6,\n  7,\n  1.5,\n  40.5],\n 9,\n [\"C:\\\\Invoices\\\\Invoices '21\\\\Paid\\\\invoice 1.xlsx\",\n  '2023-03-12 00:00:00',\n  34567,\n  40.5,\n  0.089,\n  3.6045,\n  5,\n  0,\n  49.1045])\n```\n:::\n:::\n\n\n## Compile In Excel\nSo, having all of the data we want in memory in Python, we just need to print it to an Excel table. First we open a new table, then, using simple iterating indexes for row and column print-out references to avoid issues with duplicate invoice entries, we iterate through the recorded data and print it out to a worksheet cell. A new sheet is created for the Bottom Line Info and the same process executed, and the workbook saved.\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\n# Finally, print our aggregated data to a single subitems table\nwb = pyxl.Workbook()\nws = wb.active\nr = 0\nfor row in subitems:\n    r = r+1\n    c = 0\n    for index in range(len(row)):\n        c = c+1\n        ws.cell(row=r, column=c).value = row[index]\nwb.create_sheet('Bottom Line Info')\nws = wb['Bottom Line Info']\nr = 0\nfor row in invoiceTotal:\n    r = r+1\n    c = 0\n    for index in range(len(row)):\n        c = c+1\n        ws.cell(row=r, column=c).value = row[index]\nwb.save(r\"C:\\Invoices\\Aggregated_Data.xlsx\")\nwb.close()\n```\n:::\n\n\nAnd huzzah! The file appears;\n\n![Main Folder](Folders4.png){#fig-f4}  \n\n## Output\nTaking a look at the contents, we can see the plain data laid out. Knowing how we got it, we can manually add the titles and format as a table for sorting and filtering (although this could've been done with openpyxl as well!)\n\n![Result](Folders5.png){#fig-f5}  \n\n# Afterthoughts\nI hope that you see the same potential as I did when I first really cracked open this openpyxl tool. It is so liberating to understand that we can use python to get into the guts of excel. Taken to the nth degree, you can really make excel dance with this toolset. The way I look at it is that Excel really just becomes the user-friendly GUI for whatever in the world we want to program, the upper limit on complexity really just being what we can think up and program. In that vein, I've put together nother project I hope to share sometime soon.\n\nAnother thought is as to what else we can do in the world integrating python with our ubiquitous MS Office tools! As foor for thought, here is a [blog post](https://blog.aspose.com/words/python-ms-word-automation-create-edit-or-convert-ms-word-documents-using-python/#Parse-Word-Documents-using-Python) showing how we can create and peer into Word documents using Python. I can imagine this being useful for finding a document we know is hiding somewhere in a huge directory by having the code crawl the whole directory, opening word files and performing a key word search on them.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}